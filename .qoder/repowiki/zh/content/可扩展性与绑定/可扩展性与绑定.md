# 可扩展性与绑定

<cite>
**本文档引用的文件**
- [apk_module.c](file://python/apk_module.c)
- [test_apk.py](file://python/tests/test_apk.py)
- [lua-apk.c](file://lua/lua-apk.c)
- [apk_applet.h](file://src/apk_applet.h)
- [applet.c](file://src/applet.c)
- [version.c](file://src/version.c)
- [database.c](file://src/database.c)
- [package.c](file://src/package.c)
</cite>

## 目录
1. [简介](#简介)
2. [Python绑定](#python绑定)
3. [Lua绑定](#lua绑定)
4. [C语言插件系统](#c语言插件系统)
5. [扩展方式比较](#扩展方式比较)
6. [错误处理与性能](#错误处理与性能)
7. [版本兼容性](#版本兼容性)

## 简介
apk-tools提供了多种可扩展性机制，允许开发者通过不同编程语言与工具的核心功能进行交互。本文档详细介绍了三种主要的扩展方式：Python绑定、Lua绑定和C语言插件系统。这些机制使得开发者能够查询包信息、检查安装状态、管理数据库，并根据需要扩展工具功能。

**Section sources**
- [apk_applet.h](file://src/apk_applet.h#L1-L59)
- [lua-apk.c](file://lua/lua-apk.c#L1-L339)
- [apk_module.c](file://python/apk_module.c#L1-L115)

## Python绑定

### API概览
Python绑定通过`apk_module.c`文件实现，提供了对libapk核心功能的访问。主要功能集中在`apk.version`命名空间下，包括版本验证、比较和匹配操作。

### 公开函数
- **version.validate(verstr)**: 验证版本字符串的有效性，返回布尔值
- **version.compare(verstr1, verstr2)**: 比较两个版本字符串，返回整数结果
- **version.match(verstr1, op, verstr2)**: 使用指定操作符匹配两个版本字符串，返回布尔值

### 版本常量
Python绑定导出了以下版本比较常量：
- `UNKNOWN`: 未知版本
- `EQUAL`: 相等
- `LESS`: 小于
- `GREATER`: 大于
- `FUZZY`: 模糊匹配
- `CONFLICT`: 冲突

### 使用示例
```python
import apk.version

# 验证版本字符串
print(version.validate("1.0"))  # True
print(version.validate("invalid"))  # False

# 比较版本
result = version.compare("1.0", "2.0")
print(result == version.LESS)  # True

# 版本匹配
print(version.match("1.0", version.EQUAL, "1.0"))  # True
```

**Section sources**
- [apk_module.c](file://python/apk_module.c#L1-L115)
- [test_apk.py](file://python/tests/test_apk.py#L1-L22)

## Lua绑定

### API概览
Lua绑定通过`lua-apk.c`文件实现，提供了对apk工具核心功能的访问。绑定使用元表机制来管理数据库对象的生命周期。

### 元表设计
Lua绑定使用元表来管理`apk_database`对象，实现了`__gc`（垃圾回收）方法，确保数据库连接在对象销毁时正确关闭。

### 公开方法
- **version_validate(verstr)**: 验证版本字符串
- **version_compare(verstr1, verstr2)**: 比较版本，返回"<"、"="或">"
- **version_is_less(verstr1, verstr2)**: 检查第一个版本是否小于第二个
- **db_open(options)**: 打开数据库连接，接受配置表作为参数
- **who_owns(path)**: 查询哪个包拥有指定路径
- **exists(depstr)**: 检查依赖是否满足
- **is_installed(depstr)**: 检查包是否已安装
- **installed()**: 返回已安装包的迭代器

### 方法注册机制
Lua绑定使用`luaL_Reg`数组注册方法，并通过`luaopen_apk`函数在Lua虚拟机中注册库。`reg_apk_methods`数组定义了所有可用的方法及其对应的C函数。

### 使用示例
```lua
local apk = require("apk")

-- 验证版本
print(apk.version_validate("1.0")) -- true

-- 打开数据库
local db = apk.db_open({
    root = "/",
    arch = "x86_64"
})

-- 查询文件所有者
local pkg = apk.who_owns("/bin/sh")
if pkg then
    print("Package: " .. pkg.name)
end

-- 迭代已安装的包
for pkg in apk.installed(db) do
    print(pkg.name)
end
```

**Section sources**
- [lua-apk.c](file://lua/lua-apk.c#L1-L339)

## C语言插件系统

### 插件机制
C语言插件系统通过`apk_applet.h`头文件定义，允许开发者注册自定义子命令。系统使用`APK_DEFINE_APPLET`宏在程序启动时自动注册插件。

### 核心结构
`apk_applet`结构体定义了插件的基本属性：
- `name`: 子命令名称
- `options_desc`: 选项描述
- `context_size`: 上下文大小
- `open_flags`: 打开标志
- `parse`: 选项解析函数
- `main`: 主执行函数

### 注册机制
插件通过`apk_applet_register`函数注册到全局插件列表中。`APK_DEFINE_APPLET`宏使用GCC的`__attribute__((constructor))`特性，在程序初始化时自动调用注册函数。

### 自定义子命令实现
要实现自定义子命令，需要定义一个`apk_applet`结构体实例，并使用`APK_DEFINE_APPLET`宏进行注册：

```c
static int my_command_main(void *ctx, struct apk_ctx *ac, struct apk_string_array *args) {
    // 命令逻辑
    return 0;
}

static struct apk_applet my_command_applet = {
    .name = "mycommand",
    .main = my_command_main,
};

APK_DEFINE_APPLET(my_command_applet);
```

### 使用示例
```c
#include "apk_applet.h"

static int conv_main(void *pctx, struct apk_ctx *ac, struct apk_string_array *args) {
    // 实现转换逻辑
    return 0;
}

static struct apk_applet apk_convdb = {
    .name = "convdb",
    .context_size = sizeof(struct conv_ctx),
    .main = conv_main,
};

APK_DEFINE_APPLET(apk_convdb);
```

**Section sources**
- [apk_applet.h](file://src/apk_applet.h#L1-L59)
- [applet.c](file://src/applet.c#L1-L77)

## 扩展方式比较

### 适用场景
| 扩展方式 | 适用场景 | 性能 | 开发复杂度 |
|---------|---------|------|-----------|
| Python绑定 | 脚本自动化、快速原型开发 | 中等 | 低 |
| Lua绑定 | 嵌入式脚本、配置文件处理 | 高 | 中等 |
| C语言插件 | 高性能需求、核心功能扩展 | 高 | 高 |

### 选择建议
- **Python绑定**: 适合需要快速开发和脚本化的场景，如自动化部署、配置管理
- **Lua绑定**: 适合需要嵌入脚本功能的场景，如动态配置、策略定义
- **C语言插件**: 适合需要高性能和深度集成的场景，如核心功能扩展、性能关键操作

## 错误处理与性能

### 错误处理策略
- **Python绑定**: 使用标准的Python异常机制，C函数返回NULL表示错误
- **Lua绑定**: 使用`luaL_error`报告错误，遵循Lua的错误处理惯例
- **C语言插件**: 返回负的错误码，使用`errno`兼容的错误系统

### 性能考虑
- **Python绑定**: 由于Python的GIL和解释执行特性，性能相对较低，适合I/O密集型操作
- **Lua绑定**: Lua虚拟机性能较高，JIT编译器可进一步提升性能，适合计算密集型任务
- **C语言插件**: 原生代码执行，性能最高，适合性能关键路径

### 资源管理
- **Python绑定**: 依赖Python的垃圾回收机制
- **Lua绑定**: 使用元表的`__gc`方法确保资源释放
- **C语言插件**: 需要手动管理内存和资源

**Section sources**
- [database.c](file://src/database.c#L1971-L2319)
- [version.c](file://src/version.c#L272-L331)

## 版本兼容性
所有扩展机制都设计为向后兼容。API版本通过编译时定义和运行时检查来维护。建议在开发插件时使用最新的稳定版本，并在发布前进行充分的兼容性测试。

**Section sources**
- [apk_version.h](file://src/apk_version.h#L1-L29)
- [apk_defines.h](file://src/apk_defines.h#L1-L32)